1. 分析你正在使用的DBMS。这些DBMS都使用哪些并发控制协议？支持哪些类型的恢复机制？对在22.4节中讨论的高级事务模型又提供了怎样的支持？
2. 对于下列每一个调度，说明其是否为可串行化调度、冲突可串行化调度、视图可串行化调度、可恢复调度，以及是否能够避免级联撤销。
   - read(T1, bal,), read(T2, bal,), write(T1, bal,), write(T2, balJ, commit(T1),commit(Tj
   - read(TI, b吩read(Tl, baly) ,wnte(T3, ba lJ, read(T2. ba lJ, read(T,, baly), commrt(T1), commit(T2), commit(Tl)
   - read(T1, bal,), write(T1, balJ, w汛e(T1, bal,), abort(T2), commit(T1)
   - write(T1, bal,), read(T2, balJ , write(T1, ba t,), commit(T2). abort(T1)
   - read(T,, bat,), write(T2, bal,), write(T,,bal,), read(T3, ba l,), commit(T,), commit(T?), commit(T3)
3. 给出上题中的调度(a) 到（ e) 的优先图。
4. 1. 解释什么是限定写规则。在限定写规则下，怎样测试一个调度是否为冲突可串行的？运用这种方法，判断下面的调度是否是可串行的。
S = [R 1 (Z) , R2 (Y) ， 邓（丫) . R3 (Y)凡(X) , W,(X), W1(Z), Wi(Y) , Ri(X), R , (Y) ， WI (丫) ， Wi(X) , R沁
W沁］其中R ,(Z)/W,(Z) 是指事务1 对数据项Z 的读／写操作。
   1. 基于可串行化生成并发控制算法是否明智？论证你的观点。可串行化在标准的并发控制协议算法中是如何使用的？
5. 1. 讨论怎样利用带标记的优先图对视图可串行化进行检测。
   2. 采用前面的方法，判断下列调度是否为冲突可串行的。
    (i) 5 1 = ［凡(X) , Wi(X), W1(X)]
    (ii) 52 =[W1(X), Ri{X) , W3(X). W2(X)]
    (ii i) 53 =[W， (X) ， R2(X) ， 凡(X),W3(X) ， w. (X) ， W2(X)]
6. 生成下面事务场景的等待图，并判断是否存在死锁。给出实现共享锁和互斥锁的算法。说明粒度对算法的影响。
7. 给出检测并发执行的事务是否处于死锁的算法。
8. 结合例22) 、例22.2 和例22.3 给出的事务案例，说明如何利用时间戳生成可串行化调度。
9. 图22 - 22 给出了一个维恩(Venn) 图， 说明了冲突可串行化、视图可串行化、两段锁和时间戳协议之间的关系。对该图进行扩充，使之包括乐观的和多版本的并发控制协议。进一步扩充它，使之区分2 P L 和严格2PL 、无托马斯写规则的时间戳和带托马斯写规则的时间戳
协议。
10. 解释为什么不可能实现真正的稳定存储。怎样模拟稳定存储？
11. 对DB MS 来说是动态地维护等待图更现实，还是在每次执行死锁检测算法时临时生成等待图更现实？解释你的答案。